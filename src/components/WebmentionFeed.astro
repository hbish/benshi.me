---
export interface Props {
  target: string
}

const { target } = Astro.props
---

<div class="webmentions" data-target={target}>
  <!-- Test webmention for styling verification -->
  <div class="webmentions-container">
    <div class="webmention-simple">
      <a href="#" target="_blank" title="Test User liked this" class="webmention-avatar-container">
        <img src="https://github.com/hbish.png" alt="Test User" class="webmention-avatar" />
        <span class="webmention-action-emoji">‚ù§Ô∏è</span>
      </a>
    </div>
    <div class="webmention">
      <div class="webmention-header">
        <img src="https://github.com/hbish.png" alt="Test User" class="webmention-avatar" />
        <div class="webmention-meta">
          <strong><a href="#" target="_blank">Test User</a></strong>
          <span class="webmention-action"
            ><a href="#" target="_blank">replied</a> on Jan 1, 2024</span
          >
        </div>
      </div>
      <p class="webmention-content">
        This is a test comment to verify the styling is working properly.
      </p>
    </div>
    <div class="webmention-replies">
      <div class="webmention webmention-depth-1">
        <div class="webmention-header">
          <img src="https://github.com/hbish.png" alt="Reply User" class="webmention-avatar" />
          <div class="webmention-meta">
            <strong><a href="#" target="_blank">Reply User</a></strong>
            <span class="webmention-action"
              ><a href="#" target="_blank">replied</a> on Jan 2, 2024</span
            >
          </div>
        </div>
        <p class="webmention-content">This is a threaded reply to demonstrate nesting.</p>
      </div>
    </div>
  </div>
  <div class="webmentions-empty" style="display: none;">
    <p>No interactions yet.</p>
  </div>
</div>

<script>
  class WebmentionFeed {
    constructor(element) {
      this.element = element
      this.target = element.dataset.target
      this.fetchWebmentions()
    }

    async fetchWebmentions() {
      if (!this.target) return

      try {
        const response = await fetch(
          `https://webmention.io/api/mentions.jf2?target=${encodeURIComponent(this.target)}&per-page=50`
        )
        const data = await response.json()

        if (data.children && data.children.length > 0) {
          this.renderWebmentions(data.children)
        } else {
          this.showEmpty()
        }
      } catch {
        // Silently handle fetch errors and show empty state
        this.showEmpty()
      }
    }

    renderWebmentions(webmentions) {
      const container = this.element.querySelector('.webmentions-container')
      const empty = this.element.querySelector('.webmentions-empty')

      const sortedMentions = webmentions.sort((a, b) => {
        const typeA = a['wm-property']
        const typeB = b['wm-property']

        // Priority order: likes and reposts first, then comments
        const priorityOrder = { 'like-of': 0, 'repost-of': 1, 'in-reply-to': 2, 'mention-of': 3 }
        const priorityA = priorityOrder[typeA] ?? 999
        const priorityB = priorityOrder[typeB] ?? 999

        if (priorityA !== priorityB) {
          return priorityA - priorityB
        }

        // Within same type, sort by date (newest first)
        const dateA = new Date(a.published || a['wm-received'] || 0)
        const dateB = new Date(b.published || b['wm-received'] || 0)
        return dateB - dateA
      })

      // Separate simple webmentions (likes/reposts) from full webmentions
      const simpleWebmentions = sortedMentions.filter(
        mention => mention['wm-property'] === 'like-of' || mention['wm-property'] === 'repost-of'
      )
      const fullWebmentions = sortedMentions.filter(
        mention => mention['wm-property'] !== 'like-of' && mention['wm-property'] !== 'repost-of'
      )

      // Build comment tree for threading
      const commentTree = this.buildCommentTree(fullWebmentions)

      let html = ''

      // Add avatars section if there are simple webmentions
      if (simpleWebmentions.length > 0) {
        html += '<div class="webmentions-avatars">'
        html += simpleWebmentions.map(mention => this.renderMention(mention)).join('')
        html += '</div>'
      }

      // Add threaded webmentions
      html += this.renderCommentTree(commentTree)

      container.innerHTML = html
      empty.style.display = 'none'
    }

    buildCommentTree(webmentions) {
      const topLevel = []
      const byUrl = new Map()

      // Index all webmentions by their URL
      webmentions.forEach(mention => {
        const url = mention.url || mention['wm-source']
        if (url) {
          byUrl.set(url, mention)
        }
      })

      webmentions.forEach(mention => {
        mention.replies = []

        // Check if this is a reply to another webmention
        const inReplyTo = mention['in-reply-to']
        if (inReplyTo) {
          const parent = byUrl.get(inReplyTo)
          if (parent) {
            parent.replies = parent.replies || []
            parent.replies.push(mention)
            return
          }
        }

        // If not a reply to another webmention, it's top-level
        topLevel.push(mention)
      })

      return topLevel
    }

    renderCommentTree(comments, depth = 0) {
      return comments
        .map(comment => {
          const commentHtml = this.renderMention(comment, depth)
          const repliesHtml =
            comment.replies && comment.replies.length > 0
              ? `<div class="webmention-replies">${this.renderCommentTree(comment.replies, depth + 1)}</div>`
              : ''
          return commentHtml + repliesHtml
        })
        .join('')
    }

    renderMention(mention, depth = 0) {
      const type = mention['wm-property']
      const author = mention.author || {}
      const name = author.name || 'Anonymous'
      const url = author.url || mention.url || '#'
      const avatar = author.photo || ''
      const content = mention.content?.text || mention.content?.html || ''
      const published = mention.published || mention['wm-received']
      const date = published ? new Date(published).toLocaleDateString() : ''

      const typeLabel =
        {
          'like-of': 'liked this',
          'repost-of': 'reposted this',
          'in-reply-to': 'replied',
          'mention-of': 'mentioned this',
        }[type] || 'interacted'

      // For likes and reposts, show only the linked avatar
      if (type === 'like-of' || type === 'repost-of') {
        const actionEmoji = type === 'like-of' ? 'üëç' : 'üîÑ'
        return `
          <div class="webmention webmention-simple">
            ${
              avatar
                ? `<a href="${this.escapeHtml(mention.url || url)}" target="_blank" title="${this.escapeHtml(name)} ${typeLabel}" class="webmention-avatar-container">
                <img src="${this.escapeHtml(avatar)}" alt="${this.escapeHtml(name)}" class="webmention-avatar">
                <span class="webmention-action-emoji">${actionEmoji}</span>
              </a>`
                : `<a href="${this.escapeHtml(mention.url || url)}" target="_blank" class="webmention-fallback">${this.escapeHtml(name)} ${actionEmoji}</a>`
            }
          </div>
        `
      }

      // For comments and mentions, show full layout with depth-based styling
      const depthClass = depth > 0 ? ` webmention-depth-${Math.min(depth, 3)}` : ''
      return `
        <div class="webmention${depthClass}">
          <div class="webmention-header">
            ${avatar ? `<img src="${this.escapeHtml(avatar)}" alt="${this.escapeHtml(name)}" class="webmention-avatar">` : ''}
            <div class="webmention-meta">
              <strong><a href="${this.escapeHtml(url)}" target="_blank">${this.escapeHtml(name)}</a></strong>
              <span class="webmention-action"><a href="${this.escapeHtml(mention.url || url)}" target="_blank">${typeLabel}</a>${date ? ` on ${date}` : ''}</span>
            </div>
          </div>
          ${content ? `<p class="webmention-content">${this.escapeHtml(content.substring(0, 200))}${content.length > 200 ? '...' : ''}</p>` : ''}
        </div>
      `
    }

    showEmpty() {
      const container = this.element.querySelector('.webmentions-container')
      const empty = this.element.querySelector('.webmentions-empty')
      container.innerHTML = ''
      empty.style.display = 'block'
    }

    escapeHtml(unsafe) {
      return (unsafe || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const elements = document.querySelectorAll('.webmentions')
    elements.forEach(element => new WebmentionFeed(element))
  })
</script>
